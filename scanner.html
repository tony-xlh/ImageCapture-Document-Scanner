<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document Scanner</title>
  <script src="https://cdn.jsdelivr.net/npm/dynamsoft-document-normalizer@1.0.11/dist/ddn.js"></script>
  <style>
    .full {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }

    .detectedPolygon {
      stroke:green;
      stroke-width: 2;
      fill:lime;
      opacity: 0.3;
    }

    .scannerHeader {
      top: 0;
      left: 0;
      position: absolute;
      height: 3em;
      width: 100%;
      background: rgba(0, 0, 0, 0.8);
      display: flex;
      align-items: center;
    }

    .scannerFooter {
      left: 0;
      bottom: 0;
      position: absolute;
      height: 6em;
      width: 100%;
      display: flex;
      align-items: center;
      flex-direction: row;
      justify-content: space-evenly;
      background: rgba(0, 0, 0, 0.8);
    }

    .icon {
      width: 2.5em;
      height: 2.5em;
    }

    .shutter {
      width: 4em;
      height: 4em;
      margin-top: calc(var(--shutter-size) / -2);
      margin-left: calc(var(--shutter-size) / -2);
      border-radius: 100%;
      background-color: rgb(198, 205, 216);
      padding: 12px;
      box-sizing: border-box;
    }

    .shutterButton {
      background-color: rgb(255, 255, 255);
      border-radius: 100%;
      width: 100%;
      height: 100%;
    }
  </style>
</head>
<body>
  <div class="home">
    <select class="cameraSelect"></select>
    <button class="startCameraBtn">Start Camera</button>
    <br/>
    <img class="photoTaken" />
    <br/>
    <img class="normalized" />
  </div>
  <div class="scanner full" style="display:none;">
    <div class="scannerContent">
      <video class="camera full" muted autoplay="autoplay" playsinline="playsinline" webkit-playsinline></video>
      <canvas class="hiddenCVS" style="display:none"></canvas>
      <svg class="overlay full" version="1.1" xmlns="http://www.w3.org/2000/svg"> 
      </svg>
    </div>
    <div class="scannerHeader">
      <div class="close">
        <div class="closeButton icon">
          <img src="cross.svg" alt="close">
        </div>
      </div>
    </div>
    <div class="scannerFooter">
      <div class="switch">
        <div class="switchButton icon">
          <img src="switch.svg" alt="switch">
        </div>
      </div>
      <div class="shutter">
        <div class="shutterButton"></div>
      </div>
      <div class="placeholder"></div>
    </div>
  </div>
  <script>
  const cameraSelect = document.getElementsByClassName("cameraSelect")[0];
  const video = document.querySelector('video');
  video.addEventListener('loadeddata', (event) => {
    console.log("video started");
    document.getElementsByClassName("overlay")[0].setAttribute("viewBox","0 0 "+video.videoWidth+" "+video.videoHeight);
    toggleDisplay(true);
    startDetecting();
  });
  
  document.getElementsByClassName("startCameraBtn")[0].addEventListener('click', (event) => {
    console.log("start camera");
    startSelectedCamera();
  });

  document.getElementsByClassName("shutterButton")[0].addEventListener('click', (event) => {
    capture();
    stop();
    onVideoStopped();
  });
  
  document.getElementsByClassName("closeButton")[0].addEventListener('click', (event) => {
    stop();
    onVideoStopped();
  });

  document.getElementsByClassName("switchButton")[0].addEventListener('click', (event) => {
    console.log("switch camera");
    if (cameraSelect.options.length>1) {
      if (cameraSelect.selectedIndex < cameraSelect.length - 1) {
        cameraSelect.selectedIndex = cameraSelect.selectedIndex + 1;
      }else{
        cameraSelect.selectedIndex = 0;
      }
    }
    startSelectedCamera();
  });
  
  let ddn;
  let imageCapture;
  let localStream;
  let cameraDevices = [];
  let dataCanvas;
  let interval;
  let detecting = false;
  window.onload = async function() {
    initDDN();
    await requestCameraPermission();
    await loadCameraDevices();
    loadCameraDevicesToSelect();
  }
  
  async function initDDN(){
    Dynamsoft.DDN.DocumentNormalizer.license = "DLS2eyJoYW5kc2hha2VDb2RlIjoiMjM0ODEwLTE2NTMzNTY5NzQ0ODMiLCJvcmdhbml6YXRpb25JRCI6IjIzNDgxMCJ9";
    ddn = await Dynamsoft.DDN.DocumentNormalizer.createInstance();
  }
  
  async function loadCameraDevices(){
    const constraints = {video: true, audio: false};
    const stream = await navigator.mediaDevices.getUserMedia(constraints);
    const devices = await navigator.mediaDevices.enumerateDevices();
    for (let i=0;i<devices.length;i++){
      let device = devices[i];
      if (device.kind == 'videoinput'){ // filter out audio devices
        cameraDevices.push(device);
      }
    }
  }
  
  function loadCameraDevicesToSelect(){
    for (let i=0;i<cameraDevices.length;i++){
      let device = cameraDevices[i];
      cameraSelect.appendChild(new Option(device.label,device.deviceId))
    }
  }
  
  async function requestCameraPermission() {
    const constraints = {video: true, audio: false};
    const stream = await navigator.mediaDevices.getUserMedia(constraints);
    const tracks = stream.getTracks();
    for (let i=0;i<tracks.length;i++) {
      const track = tracks[i];
      track.stop();  // stop the opened camera
    }
  }

  function toggleDisplay(cameraOn) {
    let home = document.getElementsByClassName("home")[0];
    let scanner = document.getElementsByClassName("scanner")[0];
    if (cameraOn) {
      scanner.style.display = "";
      home.style.display = "none";
    }else{
      scanner.style.display = "none";
      home.style.display = "";
    }
  }

  function startSelectedCamera(){
    let options = {};
    if (cameraSelect.selectedIndex != -1) {
      options.deviceId = cameraSelect.selectedOptions[0].value;
    }
    play(options);
  }
  
  function play(options) {
    stop(); // close before play
    let constraints = {};
  
    if (options.deviceId){
      constraints = {
        video: {deviceId: options.deviceId},
        audio: false
      }
    }else{
      constraints = {
        video: true,
        audio: false
      }
    }


    navigator.mediaDevices.getUserMedia(constraints).then(function(stream) {
      localStream = stream;
      // Attach local stream to video element      
      video.srcObject = stream;
      if ("ImageCapture" in window) {
        const track = localStream.getVideoTracks()[0];
        imageCapture = new ImageCapture(track);
        console.log("ImageCapture supported");
      }else{
        console.log("ImageCapture not supported");
      }
    }).catch(function(err) {
      console.error('getUserMediaError', err, err.stack);
    });
  }
  
  function stop() {
    try{
      if (localStream){
        const tracks = localStream.getTracks();
        for (let i=0;i<tracks.length;i++) {
          const track = tracks[i];
          track.stop();
        }
      }
    } catch (e){
      alert(e.message);
    }
  };

  function onVideoStopped(){
    stopDetecting();
    toggleDisplay(false);
  }
  
  function captureFrame(){
    let w = video.videoWidth;
    let h = video.videoHeight;
    let canvas = document.getElementsByClassName("hiddenCVS")[0];
    canvas.width  = w;
    canvas.height = h;
    let ctx = canvas.getContext('2d');
    ctx.drawImage(video, 0, 0, w, h);
    return canvas;
  }
  
  function takePhoto(){
    return new Promise(async function (resolve, reject) {
      try {
        let blob = await imageCapture.takePhoto();
        console.log(blob);
        let bitmap = await createImageBitmap(blob);
        let canvas = document.getElementsByClassName("hiddenCVS")[0];
        canvas.width  = bitmap.width;
        canvas.height = bitmap.height;
        let ctx = canvas.getContext('2d');
        ctx.drawImage(bitmap, 0, 0, bitmap.width, bitmap.height);
        resolve(canvas);
      } catch (error) {
        reject(error); //it may not work with virtual cameras
      }
    });
  }

  function startDetecting(){
    detecting = false;
    interval = setInterval(detect,200);
  }

  function stopDetecting(){
    clearInterval(interval);
  }

  async function detect() {
    if (detecting === true) {
      return;
    }
    detecting = true;
    let cvs = captureFrame();
    const quads = await ddn.detectQuad(cvs);
    detecting = false;
    if (quads.length>0) {
      let quad = quads[0];
      console.log(quad);
      drawOverlay(quad);
    }else{
      let overlay = document.getElementsByClassName("overlay")[0];
      overlay.innerHTML = "";
    }
  }

  function drawOverlay(quad){
    let points = quad.location.points;
    let overlay = document.getElementsByClassName("overlay")[0];
    overlay.innerHTML = "";
    let polygon = document.createElementNS("http://www.w3.org/2000/svg","polygon");
    polygon.setAttribute("points",getPointsData(points));
    polygon.setAttribute("class","detectedPolygon");
    overlay.appendChild(polygon);
  }

  function getPointsData(points){
    let pointsData = points[0].x + "," + points[0].y + " ";
    pointsData = pointsData + points[1].x + "," + points[1].y +" ";
    pointsData = pointsData + points[2].x + "," + points[2].y +" ";
    pointsData = pointsData + points[3].x + "," + points[3].y;
    return pointsData;
  }

  async function capture(){
    let cvs;
    if (imageCapture) {
      try {
        cvs = await takePhoto();  
      } catch (error) {
        console.log(error);
        cvs = captureFrame();  
      }
    }else{
      cvs = captureFrame();
    }
    console.log(cvs);
    document.getElementsByClassName("photoTaken")[0].src = cvs.toDataURL();
  }
  </script>
</body>
</html>